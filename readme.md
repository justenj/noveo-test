Тесты которые тестируют success ответы, ответы с ошибками валидации и Not Found ответы лежат в папке Feature. 

Unit тесты получились скудными, так как особой логики нет. Для текущего задания считаю излишним вводить скопы типа "active", "nonActive" и покрывать их тестами, так как запросов на выборку по полю "state" нет. По этой же причине это поле не индексируется.

Поле "state" модели "User" реализовано как было описано в ТЗ, но такая структруа является антипатреном, который называется "Пропуск ограничений", этот антипарн упрощает структура базы, но при его использовании, если ограничения не описаны программно (я сделал это в виде констант и проверки значения перед изменением поля "state"), данные могут потерять целостность. Я бы предпочел делать по другому, вернее у меня есть два варианта:

## Вариант 1. Булевое поле
Если предполагается, что состояний будет только два "Активный / Не активный", то нужно делать поле типа tinyint c семантичным названием "active", которые будет хранить только два значения "1" и "0", которые соответствуют значениям "Активный" и "Не активный".

## Вариант 2. Сущность "State"
Если предполагается, что состояний будет больше чем два, то создается еще одна сущность, которая называется "State". Связь этой сущности с сущностью "User" осуществляется по типу один ко многим. Данные о значении "state" пользователя хранятся в поле "state_id".

## Выбор варианта
Выбор варианта упирается в знания о количестве уникальных записей "state". Если заранее неизвестно, будут ли добавлятся новые записи "state", то имеет смысл рассмотреть сразу вариант №2. 
Но при использовании методологии TDD, можно смело использовать вариант №1, и в случаее увеличения количества уникальных записей "state", затраты ресурсов на миграцию к варианту №2 будут небольшие.
 
Так как я использую методологию TDD, я бы использовал вариант №1, потому что он более простой. При добавлении нового значения "state", выполнил бы миграцию к варианту №2. Код покрыт тестами, выполнить это было бы просто.